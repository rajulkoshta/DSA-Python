# You are given an array of integers a and two integers l and r. You task is to calculate a boolean array b, where b[i] = true if there exists an integer x, such that a[i] = (i + 1) * x and l ≤ x ≤ r. Otherwise, b[i] should be set to false.

# Example

# For a = [8, 5, 6, 16, 5], l = 1, and r = 3, the output should be solution(a, l, r) = [false, false, true, false, true].

# For a[0] = 8, we need to find a value of x such that 1 * x = 8, but the only value that would work is x = 8 which doesn't satisfy the boundaries 1 ≤ x ≤ 3, so b[0] = false.
# For a[1] = 5, we need to find a value of x such that 2 * x = 5, but there is no integer value that would satisfy this equation, so b[1] = false.
# For a[2] = 6, we can choose x = 2 because 3 * 2 = 6 and 1 ≤ 2 ≤ 3, so b[2] = true.
# For a[3] = 16, there is no an integer 1 ≤ x ≤ 3, such that 4 * x = 16, so b[3] = false.
# For a[4] = 5, we can choose x = 1 because 5 * 1 = 5 and 1 ≤ 1 ≤ 3, so b[4] = true.

# def solution(a, l, r):
#     b=[]*len(a)
#     for i in range(0,len(a)):
#         x=a[i]/(i+1)
#         y=a[i]%(i+1)
#         if x<=r and x>=l and y==0:
#             b.append(True)
#         else:
#             b.append(False) 
#     return b       

########################################################################################

# You are given an array of integers a. A new array b is generated by rearrangi the elements of a in the following way:

# b[0] is equal to a[0];
# b[1] is equal to the last element of a;
# b[2] is equal to a[1];
# b[3] is equal to the second-last element of a;
# b[4] is equal to a[2];
# b[5] is equal to the third-last element of a;
# and so on.
# Your task is to determine whether the new array b is sorted in strictly ascending order or not.

# Here is how the process of generating the new array b works:



# Example

# For a = [1, 3, 5, 6, 4, 2], the output should be solution(a) = true.

# The new array b will look like [1, 2, 3, 4, 5, 6], which is in strictly ascending order, so the answer is true.

# For a = [1, 4, 5, 6, 3], the output should be solution(a) = false.

# The new array b will look like [1, 3, 4, 6, 5], which is not in strictly ascending order, so the answer is false.

# Input/Output

# [execution time limit] 4 seconds (py3)

# [input] array.integer a

# The given array of integers.

# Guaranteed constraints:
# 1 ≤ a.length ≤ 105,
# -109 ≤ a[i] ≤ 109.

# [output] boolean

# A boolean representing whether the new array b will be sorted in strictly ascending order or not.ng



########################################################################################





# A text editor is a type of computer program that edits plain text. It consists of a string with a cursor. In the initial state the string is empty with the cursor at the beginning of the string.

# Your task is to simulate the working process of a text editor which can handle four types of operations:

# TYPE <text> - insert <text> after the current position of the cursor, where <text> consists of at most 20 characters. The cursor moves to the end of the inserted text.

# MOVE_CURSOR <offset> - change the current cursor's position. The offset specifies the direction and the value change - if it's negative the cursor moves to the left, and if it's positive the cursor moves to the right. At all times, the cursor is either located at the beginning of the string (before the first character), between two characters, or at the end of the string (after the last character) - the cursor should always be within the text bounds. If the offset is larger than cursor can move, the cursor will move towards the direction as much, as it can. If the cursor does not change its position after the operation, the operation is considered unsuccessful.

# SELECT <start_index> <end_index> - select the substring of the current text [text[start_index] ... text[end_index]] (inclusive indices, 0-based) of length end_index - start_index + 1. It is guaranteed that the indices are valid. The cursor changes its position to the end of the selected area. If the next immediately subsequent operation is not TYPE then the selected area is cleared.

# If the next immediately subsequent operation is TYPE then the following updating process is expected during the TYPE operation:

# Delete the selected text.
# Insert the new text in the place of the deleted text.
# The cursor position should move to the end of the typed text.
# If this operation is anything other than TYPE, the selected area is cleared (See the examples for details).

# UNDO - undo the last successful TYPE or MOVE_CURSOR operation (if there is nothing to undo, this operation does nothing). You cannot undo a SELECT operation. UNDO operation returns back to the text and cursor position to the state, they were before the operations is undone. Note that it's not possible to undo the same operation twice: if the operation has been undone, it's undone forever. However, it is possible to undo several operations one by one.

# You are given operations, an array of strings where each is an operation of one of the four types above. Your task is to find the resulting text after performing the given operations.

# NOTE: An operation is considered successful if the text or the cursor position is changed. For example, moving the cursor to the left when it stands before all characters is not considered a successful operation.

# Example

# For operations = ["TYPE Code", "TYPE Signal", "MOVE_CURSOR -3", "SELECT 5 8", "TYPE ou", "UNDO", "TYPE nio"], the output should be solution(operations) = "CodeSignaniol".

# Initially the text is empty,
# After the "TYPE Code" operation, the text is "Code|" (where the | symbol represents the cursor position),
# After the "TYPE Signal" operation, the text is "CodeSignal|",
# After the "MOVE_CURSOR -3", the cursor moves three symbols back, so the text is "CodeSig|nal",
# After the "SELECT 5 8" operation, the selected text is "igna", the cursor is moved to the end of selected area "CodeSigna|l",
# After the "TYPE ou" operation, since the previous operation was "SELECT", the selected text is deleted and replaced with the text "ou", the cursor stays after the typed text, so the text is "CodeSou|l",
# After the "UNDO" operation, the last operation "TYPE" is undone and text and cursor is back as it was before the "TYPE" operation, so the text is "CodeSigna|l",
# After the "TYPE nio" operation, the text is "CodeSignanio|l",
# So the final string is "CodeSignaniol".
# For operations = ["TYPE MyCat", "SELECT 2 3", "MOVE_CURSOR -1", "TYPE he", "SELECT 0 1", "TYPE His"], the output should be solution(operations) = "HisCheat".

# Initially the text is empty,
# After the "TYPE MyCat" operation, the text is "MyCat|",
# After the "SELECT 2 3" operation, the selected text is "Ca", the cursor is moved after the selected area "MyCa|t",
# After the "MOVE_CURSOR -1", the cursor moves one symbol back, so the text is "MyC|at". Also, the selected area is cleared, as this operation is not "TYPE". No area is selected,
# After the "TYPE he" operation, the text is "MyChe|at", the typed text is inserted where the cursor stands.
# After the "SELECT 0 1" operation, the selected text is "My",
# After the "TYPE His" operation, since the previous operation was "SELECT", the selected text is deleted and replaced with the text "His", the cursor moves to the end of the typed area, so the text is "His|Cheat",
# So the final string is "HisCheat".
# For operations = ["TYPE Nothing", "TYPE Is", "TYPE Permanent", "UNDO", "UNDO", "UNDO", "UNDO"], the output should be solution(operations) = "".

# Initially the text is empty,
# After the "TYPE Nothing", "TYPE is", and "TYPE Permanent" operations the text is "NothingIsPermanent",
# Then, after three consequent "UNDO" operations, the text becomes "", the last "UNDO" operation is ignored since there are no more operations to undo.
# Input/Output

# [execution time limit] 4 seconds (py3)

# [input] array.string operations

# A sequence of operations. It's guaranteed that all the operations satisfy the format described above.

# Guaranteed constraints:
# 1 ≤ operations.length ≤ 103.

# [output] string

# The resulting text after performing the given sequence of operations.

# Input:
# operations:
# ["TYPE Code", 
#  "TYPE Signal", 
#  "MOVE_CURSOR -3", 
#  "SELECT 5 8", 
#  "TYPE ou", 
#  "UNDO", 
#  "TYPE nio"]
# Expected Output:
# "CodeSignaniol"

########################################################################################

# You are given two arrays of integers a and b, and two integers lower and upper. Your task is to find the number of pairs (i, j) such that lower ≤ a[i] * a[i] + b[j] * b[j] ≤ upper.

# Example

# For a = [3, -1, 9], b = [100, 5, -2], lower = 7, and upper = 99, the output should be solution(a, b, lower, upper) = 4.

# There are only four pairs that satisfy the requirement:

# If i = 0 and j = 1, then a[0] = 3, b[1] = 5, and 7 ≤ 3 * 3 + 5 * 5 = 9 + 25 = 36 ≤ 99.
# If i = 0 and j = 2, then a[0] = 3, b[2] = -2, and 7 ≤ 3 * 3 + (-2) * (-2) = 9 + 4 = 13 ≤ 99.
# If i = 1 and j = 1, then a[1] = -1, b[1] = 5, and 7 ≤ (-1) * (-1) + 5 * 5 = 1 + 25 = 26 ≤ 99.
# If i = 2 and j = 2, then a[2] = 9, b[2] = -2, and 7 ≤ 9 * 9 + (-2) * (-2) = 81 + 4 = 85 ≤ 99.
# For a = [1, 2, 3, -1, -2, -3], b = [10], lower = 0, and upper = 100, the output should be solution(a, b, lower, upper) = 0.

# Since the array b contains only one element 10 and the array a does not contain 0, it is not possible to satisfy 0 ≤ a[i] * a[i] + 10 * 10 ≤ 100.

# Input/Output

# [execution time limit] 4 seconds (py3)

# [input] array.integer a

# A first array of integers.

# Guaranteed constraints:
# 1 ≤ a.length ≤ 105,
# -104 ≤ a[i] ≤ 104.

# [input] array.integer b

# A second array of integers.

# Guaranteed constraints:
# 1 ≤ b.length ≤ 105,
# -104 ≤ b[i] ≤ 104.

# [input] integer lower

# An integer representing a lower bound of a satisfiable square sum.

# Guaranteed constraints:
# 0 ≤ lower ≤ 109.

# [input] integer upper

# An integer representing an upper bound of a satisfiable square sum.

# Guaranteed constraints:
# lower ≤ upper,
# 0 ≤ upper ≤ 109.

# [output] integer

# The number of pairs (i, j) such, that lower ≤ a[i] * a[i] + b[j] * b[j] ≤ upper. It is guaranteed that the answer fits in 32-bit value type.


# Input:
# a: [3, -1, 9]
# b: [100, 5, -2]
# lower: 7
# upper: 99
# Expected Output:
# 4










# ########################################################################################


def solution(a):
    b=[]*len(a)
    rev = a[::-1]
    for i in range(0 , len(a)//2):   
        b.append(a[i])     
        for j in range(rev,len(a)//2+1):
            b.append(a[j]) 
         
    print(b)
    if b == sorted(b):
        return True
    else:
        return False  


print(solution([1, 4, 5, 6, 3]))